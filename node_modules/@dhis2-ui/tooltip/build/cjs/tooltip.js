"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOOLTIP_OFFSET = exports.Tooltip = void 0;

var _style = _interopRequireDefault(require("styled-jsx/style"));

var _popper = require("@dhis2-ui/popper");

var _portal = require("@dhis2-ui/portal");

var _uiConstants = require("@dhis2/ui-constants");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TOOLTIP_OFFSET = 4;
exports.TOOLTIP_OFFSET = TOOLTIP_OFFSET;
const popperStyle = {
  styles: /*#__PURE__*/_react.default.createElement(_style.default, {
    id: "2999517824"
  }, [`.jsx-2999517824{z-index:${_uiConstants.layers.applicationTop};pointer-events:none;}`, "div[data-popper-reference-hidden=\"true\"].jsx-2999517824{visibility:hidden;}"]),
  className: "jsx-2999517824"
};
const offsetModifier = {
  name: 'offset',
  options: {
    offset: [0, TOOLTIP_OFFSET]
  }
};
/**
 * For some reason the intended effects of the 'hide' modifier work with or
 * without adding it to the popper... but it may be safe to include it anyway
 */

const hideModifier = {
  name: 'hide'
};
const flipModifier = {
  name: 'flip',
  options: {
    altBoundary: true
  }
};

const Tooltip = ({
  children,
  className,
  closeDelay,
  content,
  dataTest,
  maxWidth,
  openDelay,
  placement
}) => {
  const [open, setOpen] = (0, _react.useState)(false);
  const popperReference = (0, _react.useRef)();
  const openTimerRef = (0, _react.useRef)(null);
  const closeTimerRef = (0, _react.useRef)(null);

  const onMouseOver = () => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = setTimeout(() => {
      setOpen(true);
    }, openDelay);
  };

  const onMouseOut = () => {
    clearTimeout(openTimerRef.current);
    closeTimerRef.current = setTimeout(() => {
      setOpen(false);
    }, closeDelay);
  };

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, typeof children === 'function' ? children({
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    ref: popperReference
  }) : /*#__PURE__*/_react.default.createElement("span", {
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    ref: popperReference,
    "data-test": `${dataTest}-reference`,
    className: _style.default.dynamic([["1329547013", [maxWidth, _uiConstants.colors.grey800, _uiConstants.colors.white]]])
  }, children), open && /*#__PURE__*/_react.default.createElement(_portal.Portal, null, /*#__PURE__*/_react.default.createElement(_popper.Popper, {
    className: popperStyle.className,
    placement: placement,
    reference: popperReference,
    modifiers: [offsetModifier, flipModifier, hideModifier]
  }, /*#__PURE__*/_react.default.createElement("div", {
    "data-test": `${dataTest}-content`,
    className: _style.default.dynamic([["1329547013", [maxWidth, _uiConstants.colors.grey800, _uiConstants.colors.white]]]) + " " + (className || "")
  }, content))), popperStyle.styles, /*#__PURE__*/_react.default.createElement(_style.default, {
    id: "1329547013",
    dynamic: [maxWidth, _uiConstants.colors.grey800, _uiConstants.colors.white]
  }, [`div.__jsx-style-dynamic-selector{max-width:${maxWidth}px;}`, `div.__jsx-style-dynamic-selector{padding:6px 8px;background-color:${_uiConstants.colors.grey800};border-radius:3px;color:${_uiConstants.colors.white};font-size:12px;line-height:16px;}`]));
};

exports.Tooltip = Tooltip;
Tooltip.defaultProps = {
  closeDelay: 400,
  dataTest: 'dhis2-uicore-tooltip',
  maxWidth: 300,
  openDelay: 200,
  placement: 'top'
};
Tooltip.propTypes = {
  /** If child is a function, it's called with `{ onMouseOver, onMouseOut, ref }` args to apply to a reference element. If child is a node, it is wrapped in a `span` with the appropriate attributes and handlers. */
  children: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  className: _propTypes.default.string,

  /** Time (in ms) until tooltip closes after mouse out */
  closeDelay: _propTypes.default.number,

  /** Content to display when the tooltip is open */
  content: _propTypes.default.node,
  dataTest: _propTypes.default.string,

  /** Max width of the tooltip in px */
  maxWidth: _propTypes.default.number,

  /** Time (in ms) until tooltip open after mouse over */
  openDelay: _propTypes.default.number,

  /** Where to place the tooltip relative to its reference */
  placement: _propTypes.default.oneOf(['top', 'right', 'bottom', 'left'])
};