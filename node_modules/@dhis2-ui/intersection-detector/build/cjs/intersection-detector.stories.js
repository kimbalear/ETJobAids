"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BottomArea = exports.AbsoluteTopArea = exports.AbsoluteBottomArea = exports.default = void 0;

var _style = _interopRequireDefault(require("styled-jsx/style"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _intersectionDetector = require("./intersection-detector.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const description = `
A tool to performantly detect when two components intersect, which is often better to use than scroll listeners. A common use case is to detect when a child component is in view inside a scrolling parent. Uses an [\`IntersectionObserver\`](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) object internally.

See the code examples below for examples on how to implement it.

\`\`\`js
import { IntersectionDetector } from '@dhis2/ui'
\`\`\`
`;
var _default = {
  title: 'Helpers/Intersection Observer',
  component: _intersectionDetector.IntersectionDetector,
  parameters: {
    docs: {
      description: {
        component: description
      },
      source: {
        type: 'code'
      }
    }
  },
  // Hide 'container styles' from Template in args table
  argTypes: {
    containerStyles: {
      table: {
        disable: true
      }
    }
  }
};
exports.default = _default;

const Text = () => /*#__PURE__*/_react.default.createElement("p", {
  className: "jsx-3862390236"
}, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempor venenatis hendrerit. Donec dictum sed ligula id efficitur. Suspendisse feugiat, elit in dictum imperdiet, mi tellus euismod nibh, vitae hendrerit turpis odio ut mauris. Vestibulum rhoncus interdum nunc eu eleifend. Aenean viverra nibh hendrerit nulla iaculis, vitae tincidunt erat ullamcorper. Donec tempus mattis faucibus. Donec nec lacus vitae elit aliquet pharetra. Cras vitae odio eu lorem euismod malesuada. Nunc eu rhoncus mauris. Nullam vehicula elit id vehicula maximus. Phasellus gravida tincidunt mauris, vitae laoreet erat commodo id. Nullam vitae erat ante. Proin id ultricies risus, in ultricies mauris. Vivamus lectus enim, ultricies vel egestas nec, tempor a magna. Nam sed fermentum ipsum, a ullamcorper felis. Aenean finibus erat elit, at eleifend nulla rutrum at.", /*#__PURE__*/_react.default.createElement(_style.default, {
  id: "3862390236"
}, ["p.jsx-3862390236{margin:0;}"]));

const Template = ({
  containerStyles,
  ...args
}) => {
  const rootRef = (0, _react.useRef)();
  const [isIntersecting, setIsIntersecting] = (0, _react.useState)(false);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "jsx-2697878418" + " " + "container"
  }, /*#__PURE__*/_react.default.createElement("p", {
    className: "jsx-2697878418"
  }, "Is intersecting: ", ` ${isIntersecting}`), /*#__PURE__*/_react.default.createElement("div", {
    ref: rootRef,
    className: "jsx-2697878418" + " " + "scrollContainer"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "jsx-2697878418" + " " + "contentContainer"
  }, /*#__PURE__*/_react.default.createElement(Text, null), /*#__PURE__*/_react.default.createElement("div", {
    style: containerStyles,
    className: "jsx-2697878418"
  }, /*#__PURE__*/_react.default.createElement(_intersectionDetector.IntersectionDetector, _extends({}, args, {
    onChange: ({
      isIntersecting
    }) => setIsIntersecting(isIntersecting),
    rootRef: rootRef
  }))))), /*#__PURE__*/_react.default.createElement(_style.default, {
    id: "2697878418"
  }, [".scrollContainer.jsx-2697878418{width:200px;height:300px;overflow:hidden;overflow-y:auto;}", ".contentContainer.jsx-2697878418{position:relative;}"]));
};

Template.propTypes = {
  containerStyles: _propTypes.default.shape({})
};
const boxStyles = {
  boxSizing: 'border-box',
  border: '1px solid #f76a8c',
  background: 'rgba(246,172,200,0.4)',
  width: '100%',
  height: '100px'
};
const AbsoluteBottomArea = Template.bind({});
exports.AbsoluteBottomArea = AbsoluteBottomArea;
AbsoluteBottomArea.args = {
  containerStyles: { ...boxStyles,
    position: 'absolute',
    bottom: '0',
    left: '0'
  }
};
const AbsoluteTopArea = Template.bind({});
exports.AbsoluteTopArea = AbsoluteTopArea;
AbsoluteTopArea.args = {
  containerStyles: { ...boxStyles,
    position: 'absolute',
    top: '0',
    left: '0'
  }
};
const BottomArea = Template.bind({});
exports.BottomArea = BottomArea;
BottomArea.args = {
  containerStyles: { ...boxStyles
  }
};