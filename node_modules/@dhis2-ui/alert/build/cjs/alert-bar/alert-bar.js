"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlertBar = void 0;

var _style = _interopRequireDefault(require("styled-jsx/style"));

var _propTypes = require("@dhis2/prop-types");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes2 = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _actions = require("./actions.js");

var _alertBarStyles = _interopRequireWildcard(require("./alert-bar.styles.js"));

var _dismiss = require("./dismiss.js");

var _icon = require("./icon.js");

var _message = require("./message.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const AlertBar = ({
  actions,
  children,
  className,
  critical,
  dataTest,
  duration,
  hidden,
  icon,
  permanent,
  success,
  warning,
  onHidden
}) => {
  const [inViewport, setInViewport] = (0, _react.useState)(!hidden);
  const [inDOM, setInDOM] = (0, _react.useState)(!hidden);
  const showTimeout = (0, _react.useRef)(null);
  const displayTimeout = (0, _react.useRef)(null);
  const hideTimeout = (0, _react.useRef)(null);
  const displayStartTime = (0, _react.useRef)(null);
  const displayTimeRemaining = (0, _react.useRef)(null);
  const info = !critical && !success && !warning;
  const shouldAutoHide = !(permanent || warning || critical);

  const show = () => {
    setInDOM(true);
    setInViewport(true);
  };

  const hide = () => {
    setInDOM(true);
    setInViewport(false);
  };

  const remove = () => {
    setInDOM(false);
    setInViewport(false);
    onHidden && onHidden({}, null);
  };

  const clearAllTimeouts = () => {
    clearTimeout(showTimeout.current);
    clearTimeout(displayTimeout.current);
    clearTimeout(hideTimeout.current);
  };

  const runHideAnimation = () => {
    clearAllTimeouts();
    hide();
    hideTimeout.current = setTimeout(remove, _alertBarStyles.ANIMATION_TIME);
  };

  const startDisplayTimeout = () => {
    if (shouldAutoHide) {
      clearAllTimeouts();
      displayStartTime.current = Date.now();
      displayTimeRemaining.current = duration;
      displayTimeout.current = setTimeout(runHideAnimation, displayTimeRemaining.current);
    }
  };

  const runShowAnimation = () => {
    clearAllTimeouts();
    show();
    showTimeout.current = setTimeout(startDisplayTimeout, _alertBarStyles.ANIMATION_TIME);
  };

  const pauseDisplayTimeout = () => {
    if (shouldAutoHide) {
      clearAllTimeouts();
      const elapsedTime = Date.now() - displayStartTime.current;
      displayTimeRemaining.current -= elapsedTime;
    }
  };

  const resumeDisplayTimeout = () => {
    if (shouldAutoHide) {
      clearAllTimeouts();
      displayTimeout.current = setTimeout(runHideAnimation, displayTimeRemaining.current);
    }
  };

  (0, _react.useEffect)(() => {
    // Additional check on inDOM prevents the AlertBar from briefly showing
    // when it is mounted with a hidden prop set to true
    if (hidden && inDOM) {
      runHideAnimation();
    }

    if (!hidden) {
      runShowAnimation();
    }

    return clearAllTimeouts;
  }, [hidden]);
  return !inDOM ? null : /*#__PURE__*/_react.default.createElement("div", {
    "data-test": dataTest,
    onMouseEnter: pauseDisplayTimeout,
    onMouseLeave: resumeDisplayTimeout,
    className: `jsx-${_alertBarStyles.default.__hash}` + " " + ((0, _classnames.default)(className, {
      info,
      success,
      warning,
      critical,
      inViewport
    }) || "")
  }, /*#__PURE__*/_react.default.createElement(_icon.Icon, {
    dataTest: `${dataTest}-icon`,
    icon: icon,
    critical: critical,
    success: success,
    warning: warning,
    info: info
  }), /*#__PURE__*/_react.default.createElement(_message.Message, null, children), /*#__PURE__*/_react.default.createElement(_actions.Actions, {
    actions: actions,
    hide: runHideAnimation,
    dataTest: dataTest
  }), /*#__PURE__*/_react.default.createElement(_dismiss.Dismiss, {
    onClick: runHideAnimation,
    dataTest: `${dataTest}-dismiss`
  }), /*#__PURE__*/_react.default.createElement(_style.default, {
    id: _alertBarStyles.default.__hash
  }, _alertBarStyles.default));
};

exports.AlertBar = AlertBar;
const alertTypePropType = (0, _propTypes.mutuallyExclusive)(['success', 'warning', 'critical'], _propTypes2.default.bool);
AlertBar.defaultProps = {
  duration: 8000,
  dataTest: 'dhis2-uicore-alertbar',
  icon: true
};
AlertBar.propTypes = {
  /** An array of 0-2 action objects */
  actions: _actions.actionsPropType,

  /** The message string for the alert */
  children: _propTypes2.default.string,
  className: _propTypes2.default.string,

  /** Alert bars with `critical` will not autohide */
  critical: alertTypePropType,
  dataTest: _propTypes2.default.string,
  duration: _propTypes2.default.number,
  hidden: _propTypes2.default.bool,

  /**
   * A specific icon to override the default icon in the bar.
   * If `false` is provided, no icon will be shown.
   */
  icon: _icon.iconPropType,
  permanent: _propTypes2.default.bool,
  success: alertTypePropType,

  /** Alert bars with `warning` will not autohide */
  warning: alertTypePropType,
  onHidden: _propTypes2.default.func
};